//@author: a0093895j



	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\BlinkListSystemTest\BlinkListSystemTest.cpp
	 */

		//For command "edit"
		TEST_METHOD(editTimeTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 9:00");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			ostringstream outDisplay;
			string actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Thursday, 2-4-2015:" << endl
				<< endl
				<< "1. breakfast" << endl
				<< "   Thursday        09:00                                               2-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;

			string expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}


		TEST_METHOD(editDescriptionTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 exercise");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			ostringstream outDisplay;
			string actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Thursday, 2-4-2015:" << endl
				<< endl
				<< "1. exercise" << endl
				<< "   Thursday        10:00                                               2-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;

			string expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}

		TEST_METHOD(editDateTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 3/4");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			string actualDisplay = OperationCenter::getDisplay();
			string expectedDisplay = "You have no task on Thursday, 2-4-2015\n";
			Assert::AreEqual(expectedDisplay, actualDisplay);

			OperationCenter::executeInput ("show 3/4");
			ostringstream outDisplay;
			actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Friday, 3-4-2015:" << endl
				<< endl
				<< "1. breakfast" << endl
				<< "   Friday          10:00                                               3-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;
			expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}

		TEST_METHOD(editDateTimeTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 3/4 9am");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			string actualDisplay = OperationCenter::getDisplay();
			string expectedDisplay = "You have no task on Thursday, 2-4-2015\n";
			Assert::AreEqual(expectedDisplay, actualDisplay);

			OperationCenter::executeInput ("show 3/4");
			ostringstream outDisplay;
			actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Friday, 3-4-2015:" << endl
				<< endl
				<< "1. breakfast" << endl
				<< "   Friday          09:00                                               3-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;
			expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}

		TEST_METHOD(editTimeDateTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 9am 3/4");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			string actualDisplay = OperationCenter::getDisplay();
			string expectedDisplay = "You have no task on Thursday, 2-4-2015\n";
			Assert::AreEqual(expectedDisplay, actualDisplay);

			OperationCenter::executeInput ("show 3/4");
			ostringstream outDisplay;
			actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Friday, 3-4-2015:" << endl
				<< endl
				<< "1. breakfast" << endl
				<< "   Friday          09:00                                               3-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;
			expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}

		TEST_METHOD(editDateTimeDescriptionTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 3/4 9am exercise");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			string actualDisplay = OperationCenter::getDisplay();
			string expectedDisplay = "You have no task on Thursday, 2-4-2015\n";
			Assert::AreEqual(expectedDisplay, actualDisplay);

			OperationCenter::executeInput ("show 3/4");
			ostringstream outDisplay;
			actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Friday, 3-4-2015:" << endl
				<< endl
				<< "1. exercise" << endl
				<< "   Friday          09:00                                               3-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;
			expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}

		TEST_METHOD(editTimeDateDescriptionTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 1 9am 3/4 exercise");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (acturalResponse, expectedResponse);

			string actualDisplay = OperationCenter::getDisplay();
			string expectedDisplay = "You have no task on Thursday, 2-4-2015\n";
			Assert::AreEqual(expectedDisplay, actualDisplay);

			OperationCenter::executeInput ("show 3/4");
			ostringstream outDisplay;
			actualDisplay = OperationCenter::getDisplay();
			outDisplay	<< "Your agenda for Friday, 3-4-2015:" << endl
				<< endl
				<< "1. exercise" << endl
				<< "   Friday          09:00                                               3-4-2015" << endl 
				<< "________________________________________________________________________________"<< endl;
			expectedDisplay = outDisplay.str();
			Assert::AreEqual(expectedDisplay, actualDisplay);
		}

		TEST_METHOD(editErrorMessageTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			OperationCenter::executeInput ("edit 9am 3/4 exercise");

			string acturalResponse = OperationCenter::getResponse();
			string expectedResponse = "Please enter correct task number after command word";
			Assert::AreEqual (acturalResponse, expectedResponse);
		}

		TEST_METHOD(undoAddTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You have undone your operation\n";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(undoEditTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("edit 1 9:00");
			string actualEditResponse = OperationCenter::getResponse(); 
			string expectedEditResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is edited\n";
			Assert::AreEqual (actualEditResponse, expectedEditResponse);

			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You have undone your operation\n";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(undoDeleteTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("delete 1");
			string actualDeleteResponse = OperationCenter::getResponse(); 
			string expectedDeleteResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is deleted from BlinkList\n";
			Assert::AreEqual (actualDeleteResponse, expectedDeleteResponse);

			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You have undone your operation\n";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(undoDoneTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("done 1");
			string actualDoneResponse = OperationCenter::getResponse(); 
			string expectedDoneResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is done\n";
			Assert::AreEqual (actualDoneResponse, expectedDoneResponse);

			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You have undone your operation\n";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(undoUndoneTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("done 1");
			string actualDoneResponse = OperationCenter::getResponse(); 
			string expectedDoneResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is done\n";
			Assert::AreEqual (actualDoneResponse, expectedDoneResponse);

			OperationCenter::executeInput ("show done");
			OperationCenter::executeInput ("undone 1");
			string actualUndoneResponse = OperationCenter::getResponse(); 
			string expectedUndoneResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is reopened\n";
			Assert::AreEqual (actualUndoneResponse, expectedUndoneResponse);

			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You have undone your operation\n";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(undoClearTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("add 3/4 1pm lunch");
			actualAddResponse = OperationCenter::getResponse(); 
			expectedAddResponse = "lunch on Friday, 3-4-2015 at 13:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("add 4/4 6pm dinner");
			actualAddResponse = OperationCenter::getResponse(); 
			expectedAddResponse = "dinner on Saturday, 4-4-2015 at 18:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("clear");
			string actualClearResponse = OperationCenter::getResponse(); 
			string expectedClearResponse = "all contents are cleared";
			Assert::AreEqual (actualClearResponse, expectedClearResponse);

			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You have undone your operation\n";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(undoErrorTest)			
		{
			OperationCenter::executeInput ("clear");
			OperationCenter::executeInput ("add 2/4 10am breakfast");
			string actualAddResponse = OperationCenter::getResponse(); 
			string expectedAddResponse = "breakfast on Thursday, 2-4-2015 at 10:00 is added\n";
			Assert::AreEqual (actualAddResponse, expectedAddResponse);

			OperationCenter::executeInput ("undo");
			OperationCenter::executeInput ("undo");
			string actualUndoResponse = OperationCenter::getResponse(); 
			string expectedUndoResponse = "You can only undo the latest command and undo once";
			Assert::AreEqual (actualUndoResponse, expectedUndoResponse);
		}

		TEST_METHOD(pathTest)			
		{
			OperationCenter::executeInput ("path E:/focus");
			string actualResponse = OperationCenter::getResponse(); 
			string expectedResponse = "New user path: E:/focus\n"
				"Please type 'show commands' or 'show features' to get started\n";
			Assert::AreEqual (actualResponse, expectedResponse);
		}

		TEST_METHOD(pathErrorTest)			
		{
			OperationCenter::executeInput ("path C:/focus");
			string actualResponse = OperationCenter::getResponse(); 
			string expectedResponse = "Please reinput path ";
			Assert::AreEqual (actualResponse, expectedResponse);
		}

	// End of segment: C:\Users\Yang\Desktop\Projects\main\BlinkListSystemTest\BlinkListSystemTest.cpp





	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\Parser\Parser.cpp
	 */

#include "Parser.h"

const unsigned int Parser::LENGTH_OF_DATE_NUMBER = 3;  //"d/m"
const unsigned int Parser::LENGTH_OF_DATE_ALPHABET = 5;  //"d MMM"
const unsigned int Parser::LENGTH_OF_YEAR_ALPHABET = 5;
const unsigned int Parser::LENGTH_OF_STARTING_TIME = 4;  //"9:00"
const unsigned int Parser::LENGTH_OF_TIME_PERIOD = 9;  //"9:00-9:30"
const unsigned int Parser::START_OF_YEAR = 1900;
const unsigned int Parser::YEAR_MIN = 2000;
const unsigned int Parser::YEAR_MAX = 2100;

const unsigned int Parser::ZERO = 0;
const unsigned int Parser::ONE = 1;
const unsigned int Parser::TWO = 2;
const unsigned int Parser::THREE = 3;
const unsigned int Parser::FOUR = 4;
const unsigned int Parser::FIVE = 5;
const unsigned int Parser::SIX = 6;
const unsigned int Parser::SEVEN = 7;
const unsigned int Parser::EIGHT = 8;
const unsigned int Parser::NINE = 9;
const unsigned int Parser::TEN = 10;
const unsigned int Parser::ELEVEN = 11;
const unsigned int Parser::TWELVE = 12;
const unsigned int Parser::TWENTY_THREE = 23;
const unsigned int Parser::TWENTY_EIGHT = 28;
const unsigned int Parser::TWENTY_NINE = 29;
const unsigned int Parser::THIRTY = 30;
const unsigned int Parser::THIRTY_ONE = 31;
const unsigned int Parser::FIFTY_NINE = 59;
const unsigned int Parser::HUNDRAD = 100;
const unsigned int Parser::FOUR_HUNDRAD = 400;
const char Parser::AM[] = "am";
const char Parser::PM[] = "pm";
const char Parser::M[] = "m";

const unsigned int Parser::TIMEMICRO_INITIAL = -1;
const char Parser::EMPTY_STRING[] = "";
const char Parser::SPACE[] = " ";
const char Parser::SLASH[] = "/";
const char Parser::SPACE_SLASH[] = " /";
const char Parser::COLON[] = ":";
const char Parser::DOT[] = ".";
const char Parser::DASH[] = "-";

const char Parser::JAN_CAP[] = "Jan";
const char Parser::FEB_CAP[] = "Feb";
const char Parser::MAR_CAP[] = "Mar";
const char Parser::APR_CAP[] = "Apr";
const char Parser::MAY_CAP[] = "May";
const char Parser::JUN_CAP[] = "Jun";
const char Parser::JUL_CAP[] = "Jul";
const char Parser::AUG_CAP[] = "Aug";
const char Parser::SEP_CAP[] = "Sep";
const char Parser::OCT_CAP[] = "Oct";
const char Parser::NOV_CAP[] = "Nov";
const char Parser::DEC_CAP[] = "Dec";
const char Parser::JAN_SMALL[] = "jan";
const char Parser::FEB_SMALL[] = "feb";
const char Parser::MAR_SMALL[] = "mar";
const char Parser::APR_SMALL[] = "apr";
const char Parser::MAY_SMALL[] = "may";
const char Parser::JUN_SMALL[] = "jun";
const char Parser::JUL_SMALL[] = "jul";
const char Parser::AUG_SMALL[] = "aug";
const char Parser::SEP_SMALL[] = "sep";
const char Parser::OCT_SMALL[] = "oct";
const char Parser::NOV_SMALL[] = "nov";
const char Parser::DEC_SMALL[] = "dec";

const char Parser::MONDAY[] = "Monday";
const char Parser::TUESDAY[] = "Tuesday";
const char Parser::WEDNESDAY[] = "Wednesday";
const char Parser::THURSDAY[] = "Thursday";
const char Parser::FRIDAY[] = "Friday";
const char Parser::SATURDAY[] = "Saturday";
const char Parser::SUNDAY[] = "Sunday";

const char Parser::COMMAND_ADD[] = "add";
const char Parser::COMMAND_EDIT[] = "edit";
const char Parser::COMMAND_SEARCH[] = "search";
const char Parser::COMMAND_UNDO[] = "undo";
const char Parser::COMMAND_DELETE[] = "delete";
const char Parser::COMMAND_DONE[] = "done";
const char Parser::COMMAND_UNDONE[] = "undone";
const char Parser::COMMAND_SHOW[] = "show";
const char Parser::COMMAND_CLEAR[] = "clear";
const char Parser::COMMAND_PATH[] = "path";
const char Parser::COMMAND_HELP[] = "help";
const char Parser::COMMAND_TODAY[] = "today";
const char Parser::COMMAND_TOMORROW[] = "tomorrow";
const char Parser::COMMAND_THIS_WEEK[] = "this week";
const char Parser::COMMAND_THIS_MONTH[] = "this month";
const char Parser::COMMAND_COMMANDS[] = "commands";
const char Parser::COMMAND_FLOAT[] = "float";
const char Parser::COMMAND_FEATURES[] = "features";

const char Parser::ERROR_MESSAGE_COMMAND[] = "Please enter the correct command";
const char Parser::ERROR_MESSAGE_INPUT[] = "Please enter correct input following the command word";
const char Parser::ERROR_MESSAGE_EDIT[] = "Please enter content you want to edit";
const char Parser::ERROR_MESSAGE_TASK_NO[] = "Please enter correct task number after command word";
const char Parser::ERROR_MESSAGE_SHOW[] = "Please enter correct time period or task type";
const char Parser::ERROR_MESSAGE_DIRECTORY[] = "Please enter the correct directory";
const char Parser::ERROR_MESSAGE_DATE[] = "Please enter the correct date";
const char Parser::ERROR_MESSAGE_YEAR[] = "Please enter the correct year";
const char Parser::ERROR_MESSAGE_TIME[] = "Please enter the correct time";
const char Parser::ERROR_MESSAGE_DESC[] = "Please enter task description";

const char Parser::LOG_START[] = "Parser starts to parse user input";
const char Parser::LOG_SUCCESS[] = "Parser has parsed user input successfully";
const char Parser::LOG_ERROR[] = "Parser has found an invalid user input";



//This method is called by OperationCenter.
//It takes in user's input message
//and updates error message if the user's command word is incorrect.
void Parser::parseInput (string userInput) {
	string commandWord;
	Logger logStart;
	logStart.logging (LOG_START);

	commandWord = extractCommandWord (userInput);

	try {
		checkCommandWord (userInput, commandWord);
		Logger logSuccess;
		logSuccess.logging (LOG_SUCCESS);
	}

	catch (const char* errorMessge) {
		Logger logError;
		Logger logMessage;
		logError.logging (LOG_ERROR);
		logMessage.logging (errorMessge);
		updateErrorMessage (errorMessge);
	}
}


//This method is to recognise different user's command word
//and call for different actions accordingly.
//If the user enters an incorrect command word,
//it will throw an exception.
void Parser::checkCommandWord (string userInput, string commandWord) {
	if (commandWord == COMMAND_ADD) {
		parseAdd (userInput, commandWord);
	}
	else if (commandWord == COMMAND_EDIT) {
		parseEdit (userInput, commandWord);
	}
	else if (commandWord == COMMAND_SEARCH) {
		parseSearch (userInput, commandWord);
	}
	else if (commandWord == COMMAND_UNDO) {
		parseUndo (userInput, commandWord);
	}
	else if (commandWord == COMMAND_DELETE) {
		parseDelete (userInput, commandWord);
	}
	else if (commandWord == COMMAND_DONE) {
		parseDone (userInput, commandWord);
	}
	else if (commandWord == COMMAND_UNDONE) {
		parseUndone (userInput, commandWord);
	}
	else if (commandWord == COMMAND_SHOW) {
		parseShow (userInput, commandWord);
	}
	else if (commandWord == COMMAND_CLEAR) {
		parseClear (userInput, commandWord);
	}
	else if (commandWord == COMMAND_PATH) {
		parsePath (userInput, commandWord);
	}
	else if (commandWord == COMMAND_HELP) {
		parseHelp (userInput, commandWord);
	}
	else {
		throw ERROR_MESSAGE_COMMAND;
	}
}


//This method is to extract command word 
//which is the first word from the user's input.
//It assumes each word is separated by a whitespace in user's input.
//If the user input only consists one word,
//this single word will be extracted.
string Parser::extractCommandWord (string userInput) {
	int end = 0;
	string commandWord;
	end = userInput.find_first_of (SPACE);
	commandWord = userInput.substr (ZERO, end);
	return commandWord;
}


//This method is to parse user's input if the command word is "add".
//There are at most 3 things to be parsed:
//date, time and task description.
//A task must have a description and end with a description
//else, an exception will be thrown.
//Date and time may be omitted and they can switch order if there are any
//If a task only has a time but no date,
//it assumes to be today.
void Parser::parseAdd (string userInput, string commandWord) {
	TimeMacro timeMacro;
	TimeMicro timeMicroBeg;
	TimeMicro timeMicroEnd;
	string inputToBeParsed = userInput;
	string desc;

	inputToBeParsed = inputToBeParsed.substr (commandWord.size());
	if (inputToBeParsed != EMPTY_STRING && inputToBeParsed != SPACE) {
		//This "if" condition is to account for the cases where
		//the user only enters the command word
		//or enters a command word followed by a white space.
		//These cases may usually happen when the users are careless.
		inputToBeParsed = inputToBeParsed.substr (ONE);

		parseDateNumber (inputToBeParsed, timeMacro);
		parseDateAlphabet (inputToBeParsed, timeMacro);

		parseTimeTwentyFour (inputToBeParsed, timeMicroBeg, timeMicroEnd);
		parseTimeTwelve (inputToBeParsed, timeMicroBeg, timeMicroEnd);

		if (timeMacro.getDate() == ZERO &&
			timeMacro.getMonth() == ZERO &&
			timeMacro.getYear() == ZERO) {
				parseDateNumber (inputToBeParsed, timeMacro);
				parseDateAlphabet (inputToBeParsed, timeMacro);
		}
		//This "if" block is to make sure the date can be parsed
		//even if it is put after the time.
		
		desc = inputToBeParsed;

		if (desc == EMPTY_STRING) {
			throw ERROR_MESSAGE_DESC;
		}

		updateCommand (commandWord);
		updateTimeMacro (timeMacro);
		updateTimeMicroPeriod (timeMicroBeg, timeMicroEnd);
		updateDesc (desc);

		if (timeMacro.getDate() == ZERO &&
			timeMicroBeg.getHour() != TIMEMICRO_INITIAL) {
				getTodayDate (timeMacro);
		}
		updateTimeMacro (timeMacro);
	}
	else {
		throw ERROR_MESSAGE_INPUT;
	}
}


//This method is to parse user's input if the command word is "edit".
//There are at most 4 things to be parsed:
//task number, date, time and task description.
//The command word "edit" must be followed by a task number.
//a task will end with a description if there is one
//date, time and description can also stand alone and switch order
//The task number must be followed by something to edit
void Parser::parseEdit (string userInput, string commandWord) {
	TimeMacro timeMacro;
	TimeMicro timeMicroBeg;
	TimeMicro timeMicroEnd;
	string desc;
	int taskNo;
	string inputToBeParsed;
	string index;

	inputToBeParsed = userInput.substr (commandWord.size());
	if (inputToBeParsed != EMPTY_STRING && inputToBeParsed != SPACE) {
		inputToBeParsed = inputToBeParsed.substr (ONE);

		index = parseTaskNo (inputToBeParsed);
		taskNo = convertStringToInteger (index);
		if (taskNo < ONE) {
			throw ERROR_MESSAGE_TASK_NO;
		}

		inputToBeParsed = inputToBeParsed.substr(index.size ());
		if (inputToBeParsed != EMPTY_STRING && inputToBeParsed != SPACE) {
			inputToBeParsed = inputToBeParsed.substr(ONE);

			parseDateNumber (inputToBeParsed, timeMacro);
			parseDateAlphabet (inputToBeParsed, timeMacro);

			parseTimeTwentyFour (inputToBeParsed, timeMicroBeg, timeMicroEnd);
			parseTimeTwelve (inputToBeParsed, timeMicroBeg, timeMicroEnd);

			if (timeMacro.getDate() == ZERO &&
				timeMacro.getMonth() == ZERO &&
				timeMacro.getYear() == ZERO) {
					parseDateNumber (inputToBeParsed, timeMacro);
					parseDateAlphabet (inputToBeParsed, timeMacro);
			}

			desc = inputToBeParsed;

			updateCommand (commandWord);
			updateTaskNo (taskNo);
			updateTimeMacro (timeMacro);
			updateTimeMicroPeriod (timeMicroBeg, timeMicroEnd);
			updateDesc (desc);
		}

		else {
			throw ERROR_MESSAGE_EDIT;
		}
	}
	else {
		throw ERROR_MESSAGE_INPUT;
	}
}

//This method is to parse user's input if the command word is "search".
//The whole string after the command word "search" will be parsed
//and recognised as the key word.
void Parser::parseSearch (string userInput, string commandWord) {
	string desc = userInput.substr (commandWord.size());
	int end = 0;
	if (desc != EMPTY_STRING && desc != SPACE) {
		desc = desc.substr (ONE);

		updateCommand (commandWord);
		updateDesc (desc);
	}
	else {
		throw ERROR_MESSAGE_INPUT;
	}
}


//This method is to parse user's input if the command word is "undo".
//Only the command word "undo" will be parsed.
void Parser::parseUndo (string userInput, string commandWord) {
    updateCommand (commandWord);

	string leftOver = userInput.substr (commandWord.size());
	if (leftOver != EMPTY_STRING && leftOver != SPACE) {
		throw ERROR_MESSAGE_COMMAND;
	}
}


//This method is to parse user's input if the command word is "delete".
//The command word "delete" must be followed by a task number.
void Parser::parseDelete (string userInput, string commandWord) {
	int taskNo;
	string index = userInput.substr (commandWord.size());
	if (index != EMPTY_STRING && index != SPACE) {
		index = index.substr (ONE);
		taskNo = convertStringToInteger (index);
		if (taskNo < ONE) {
			throw ERROR_MESSAGE_TASK_NO;
		}
		updateCommand (commandWord);
		updateTaskNo (taskNo);
	}
	else {
		throw ERROR_MESSAGE_TASK_NO;
	}
}


//This method is to parse user's input if the command word is "done".
//The command word "done" must be followed by a task number.
void Parser::parseDone (string userInput, string commandWord) {
	int taskNo;
	string index = userInput.substr (commandWord.size());
	if (index != EMPTY_STRING && index != SPACE) {
		index = index.substr (ONE);
		taskNo = convertStringToInteger (index);
		if (taskNo < ONE) {
			throw ERROR_MESSAGE_TASK_NO;
		}
		updateCommand (commandWord);
		updateTaskNo (taskNo);
		updateStatus (true);
	}
	else {
		throw ERROR_MESSAGE_TASK_NO;
	}
}


//This method is to parse user's input if the command word is "undone".
//The command word "undone" must be followed by a task number.
void Parser::parseUndone (string userInput, string commandWord) {
	int taskNo;
	string index = userInput.substr (commandWord.size());
	if (index != EMPTY_STRING && index != SPACE) {
		index = index.substr (ONE);
		taskNo = convertStringToInteger (index);
		if (taskNo < ONE) {
			throw ERROR_MESSAGE_TASK_NO;
		}
		updateCommand (commandWord);
		updateTaskNo (taskNo);
		updateStatus (false);
	}
	else {
		throw ERROR_MESSAGE_TASK_NO;
	}
}

//This method is to parse user's input if the command word is "show".
//1st case: the command word "show" is followed by a date.
//Then the date/month/year/day will be updated.
//2nd case: the command word "show" is followed by a period.
//The user can enter "show today", "show tomorrow",
//"show this week" and "show this month".
//The starting and ending date/month/year/day will be updated.
//3rd case: the command word "show" is followed by the 
//words "commands", "float", "done", or "features".
//Then the command word will become "show commands" or "show float", etc.
//If the word following "show" does not fall into these 2 cases,
//it will throw an exception.
void Parser::parseShow (string userInput, string commandWord) {
	string inputToBeParsed = userInput.substr (commandWord.size ());
	TimeMacro timeMacroBeg;
	TimeMacro timeMacroEnd;
	int dateInt;
	int monthInt;

	if (inputToBeParsed != EMPTY_STRING && inputToBeParsed != SPACE) {
		inputToBeParsed = inputToBeParsed.substr(ONE);

		if (isDateNumber (inputToBeParsed, dateInt, monthInt) ||
			isDateAlphabet (inputToBeParsed, dateInt)) {
				parseDateNumber (inputToBeParsed, timeMacroBeg);
				parseDateAlphabet (inputToBeParsed, timeMacroBeg);

				if (inputToBeParsed != EMPTY_STRING && inputToBeParsed != SPACE) {
					throw ERROR_MESSAGE_SHOW;
				}

				updateCommand (commandWord);
				timeMacroEnd = timeMacroBeg;
				updateTimeMacroPeriod (timeMacroBeg, timeMacroEnd);
		}		
		else if (inputToBeParsed == COMMAND_TODAY) {
			getTodayDate (timeMacroBeg);
			timeMacroEnd = timeMacroBeg;
			updateCommand (commandWord);
			updateTimeMacroPeriod (timeMacroBeg, timeMacroEnd);
		}
		else if (inputToBeParsed == COMMAND_TOMORROW) {
			getTomorrowDate (timeMacroBeg);
			timeMacroEnd = timeMacroBeg;
			updateCommand (commandWord);
			updateTimeMacroPeriod (timeMacroBeg, timeMacroEnd);
		}
		else if (inputToBeParsed == COMMAND_THIS_WEEK) {
			getMondayDate (timeMacroBeg);
			getSundayDate (timeMacroEnd);
			updateCommand (commandWord);
			updateTimeMacroPeriod (timeMacroBeg, timeMacroEnd);
		}
		else if (inputToBeParsed == COMMAND_THIS_MONTH) {
			getThisMonth (timeMacroBeg, timeMacroEnd);
			updateCommand (commandWord);
			updateTimeMacroPeriod (timeMacroBeg, timeMacroEnd);
		}
		else if (inputToBeParsed == COMMAND_COMMANDS ||
			inputToBeParsed == COMMAND_FLOAT ||
			inputToBeParsed == COMMAND_DONE ||
			inputToBeParsed == COMMAND_FEATURES) {
				commandWord = commandWord + SPACE + inputToBeParsed;
				updateCommand (commandWord);
		}
		else {
			throw ERROR_MESSAGE_SHOW;
		}
	}
	else {
		throw ERROR_MESSAGE_SHOW;
	}
}


//This method is to parse user's input if the command word is "clear".
//Only the command word "clear" will be parsed.
//If the command word "clear" is followed by some other input,
//an exception is thrown.
void Parser::parseClear (string userInput, string commandWord) {
	updateCommand (commandWord);

	string leftOver = userInput.substr (commandWord.size());
	if (leftOver != EMPTY_STRING && leftOver != SPACE) {
		throw ERROR_MESSAGE_COMMAND;
	}
}


//This method is to parse user's input if the command word is "path".
//The command word "path" must be followed by a directory.
void Parser::parsePath (string userInput, string commandWord) {
	string inputToBeParsed = userInput.substr (commandWord.size ());

	if (inputToBeParsed != EMPTY_STRING && inputToBeParsed != SPACE) {
		inputToBeParsed = inputToBeParsed.substr(ONE);

		updateCommand (commandWord);
		updateDirectory (inputToBeParsed);	
	}
	else {
		throw ERROR_MESSAGE_DIRECTORY;
	}
}


//This method is to parse user's input if the command word is "help".
//Only the command word "help" will be parsed.
//If the command word "help" is followed by some other input,
//an exception is thrown.
void Parser::parseHelp (string userInput, string commandWord) {
	updateCommand (commandWord);

	string leftOver = userInput.substr (commandWord.size());
	if (leftOver != EMPTY_STRING && leftOver != SPACE) {
		throw ERROR_MESSAGE_COMMAND;
	}
}


//This method is to parse date after the start of the string is recoganised as a date.
//The formats it recognises are "dd/mm/yyyy", "d/mm/yyyy", "dd/m/yyyy", "d/m/yyyy",
//"dd/mm", "d/mm", "dd/m", "d/m".
//If the year is not specified, it assumes to be this year.
//Date/month/year/day will be updated.
void Parser::parseDateNumber (string& inputToBeParsesd, TimeMacro& timeMacro) {
	int end = 0;
	int dateInt;
	int monthInt;
	int yearInt;
	string day;

	if (isDateNumber (inputToBeParsesd, dateInt, monthInt)) {
		timeMacro.updateDate (dateInt);
		timeMacro.updateMonth (monthInt);

		end = inputToBeParsesd.find_first_of (SLASH);
		inputToBeParsesd = inputToBeParsesd.substr (end + ONE);
		if (isYearNumber (inputToBeParsesd, yearInt)) {
			timeMacro.updateYear (yearInt);
		}
		else {
			time_t t = time (ZERO);
			struct tm now;
			localtime_s (&now, &t);
			now.tm_year = now.tm_year + START_OF_YEAR;
			yearInt = now.tm_year;
			timeMacro.updateYear (yearInt);
		}

		day = convertDateToDayOfTheWeek (dateInt, monthInt, yearInt);
		timeMacro.updateDay (day);

		end = inputToBeParsesd.find_first_of (SPACE);
		if (end != string::npos) {
			inputToBeParsesd = inputToBeParsesd.substr (end + ONE);
		}
		else {
			inputToBeParsesd = EMPTY_STRING;
		}
	}
}


//This method is to parse date after the start of the string is recoganised as a date.
//The formats it recognises are date (integer) followed by month (abbreviation),
//followed by year (integer). eg. 21 Mar 2015
//If the year is not specified, it assumes it is this year.
//Date/month/year/day will be updated.
void Parser::parseDateAlphabet (string& inputToBeParsesd, TimeMacro& timeMacro) {
	int end = 0;
	int dateInt;
	int monthInt;
	int yearInt;
	string day;

	if (isDateAlphabet (inputToBeParsesd, dateInt)) {
		timeMacro.updateDate (dateInt);

		end = inputToBeParsesd.find_first_of (SPACE);
		inputToBeParsesd = inputToBeParsesd.substr (end + ONE);
		monthInt = convertAlphabetMonthToInteger (inputToBeParsesd.substr (ZERO, THREE));
		timeMacro.updateMonth (monthInt);
		inputToBeParsesd = inputToBeParsesd.substr (THREE);

		if (isYearAlphabet (inputToBeParsesd, yearInt)) {
			timeMacro.updateYear (yearInt);
			if (inputToBeParsesd.size() > SIX) {
				inputToBeParsesd = inputToBeParsesd.substr (SIX); //there is still content after the year
			}
			else {
				inputToBeParsesd = EMPTY_STRING;
			}
		}

		else {
			if (inputToBeParsesd.size() > ONE) {
				inputToBeParsesd = inputToBeParsesd.substr (ONE);
			}

			time_t t = time (ZERO);
			struct tm now;
			localtime_s (&now, &t);
			now.tm_year = now.tm_year + START_OF_YEAR;
			yearInt = now.tm_year;
			timeMacro.updateYear (yearInt);
		}

		day = convertDateToDayOfTheWeek (dateInt, monthInt, yearInt);
		timeMacro.updateDay (day);
	}
}

//This method is to parse date after the start of the string 
//is recoganised as a time or a time period.
//It recoganise the time format "hh:mm" and parse it accordingly.
//If the string starts with a time,
//only starting hour and minute will be updated.
//If the string starts with a time period,
//both starting and ending hour and minute will be updated.
void Parser::parseTimeTwentyFour (string& inputToBeParsed, TimeMicro& timeMicroBeg, TimeMicro& timeMicroEnd) {
	int end = 0;
	int hourBegInt;
	int hourEndInt;
	int minuteBegInt;
	int minuteEndInt;

	if (isTimePeriodTwentyFour (inputToBeParsed, hourBegInt, hourEndInt, minuteBegInt, minuteEndInt) ||
		isStartingTimeTwentyFour (inputToBeParsed, hourBegInt, minuteBegInt)) {
			timeMicroBeg.updateHour (hourBegInt);
			timeMicroBeg.updateMin (minuteBegInt);

			if (isTimePeriodTwentyFour (inputToBeParsed, hourBegInt, hourEndInt, minuteBegInt, minuteEndInt)) {	
				timeMicroEnd.updateHour (hourEndInt);
				timeMicroEnd.updateMin (minuteEndInt);
				assert (timeMicroEnd.getHour() != TIMEMICRO_INITIAL);
				assert (timeMicroEnd.getMin() != TIMEMICRO_INITIAL);
			}

			assert (timeMicroBeg.getHour() != TIMEMICRO_INITIAL);
			assert (timeMicroBeg.getMin() != TIMEMICRO_INITIAL);

			end = inputToBeParsed.find_first_of (SPACE);
			if (end == string::npos) {
				inputToBeParsed = EMPTY_STRING;
			}
			else {
				inputToBeParsed = inputToBeParsed.substr (end + ONE);
			}
	}
}


//This method is to parse date after the start of the string 
//is recoganised as a time or a time period.
//The formats it recognises are "hh", "h", "hh.mm", "h.mm"
//followed by "am" or "pm".
//If the string starts with a time,
//only starting hour and minute will be updated.
//If the string starts with a time period,
//both starting and ending hour and minute will be updated.
void Parser::parseTimeTwelve (string& inputToBeParsed, TimeMicro& timeMicroBeg, TimeMicro& timeMicroEnd) {
	int end = 0;
	int hourBegInt;
	int hourEndInt;
	int minuteBegInt;
	int minuteEndInt;

	if (isTimePeriodTwelve (inputToBeParsed, hourBegInt, hourEndInt, minuteBegInt, minuteEndInt) ||
		isStartingTimeTwelve (inputToBeParsed, hourBegInt, minuteBegInt)) {
			timeMicroBeg.updateHour (hourBegInt);
			timeMicroBeg.updateMin (minuteBegInt);

			if (isTimePeriodTwelve (inputToBeParsed, hourBegInt, hourEndInt, minuteBegInt, minuteEndInt)) {				
				timeMicroEnd.updateHour (hourEndInt);
				timeMicroEnd.updateMin (minuteEndInt);
				assert (timeMicroEnd.getHour() != TIMEMICRO_INITIAL);
				assert (timeMicroEnd.getMin() != TIMEMICRO_INITIAL);
			}

			assert (timeMicroBeg.getHour() != TIMEMICRO_INITIAL);
			assert (timeMicroBeg.getMin() != TIMEMICRO_INITIAL);

			end = inputToBeParsed.find_first_of (SPACE);
			if (end == string::npos) {
				inputToBeParsed = EMPTY_STRING;
			}
			else {
				inputToBeParsed = inputToBeParsed.substr (end + ONE);
			}
	}	
}

//This method is to parse the task numnber.
//It assumes the task number is separated with the following string
//with a whitespace,
//or the task number is the end of the string.
//The task number returned is a string.
string Parser::parseTaskNo (string inputToBeParsed) {
	int lengthOfTaskNo = inputToBeParsed.find_first_of (SPACE);
	string index = inputToBeParsed.substr (ZERO, lengthOfTaskNo);
	return index;
}


//This method is to check whether an input string is an interger string
//It will return false if at least one character is not integer character
bool Parser::isInteger (string index) {
	for (int i = 0; i != index.size (); i++) {
		if (!isdigit (index[i])) {
			return false;
		}
	}
	return true;
}


//This method is to convert an input string to an integer.
//An exception will be thrown if the string is not an integer string.
int Parser::convertStringToInteger (string index) {
	if (!isInteger (index)) {
		throw ERROR_MESSAGE_TASK_NO;
	}
	else {
		int taskNo = atoi (index.c_str());
		return taskNo;
	}	
}

//This method is to check if the start of the string is a date.
//This method only checks for date and month.
//The formats of date and month can be
//"dd/mm", "dd/m", "d/mm", "d/m".
//The string firstly needs to be longer than the date format.
bool Parser::isDateNumber (string inputToBeParsed, int& dateInt, int& monthInt) {
	int end;
	string date;
	string month;

	if (inputToBeParsed.size() >= LENGTH_OF_DATE_NUMBER) {
		end = inputToBeParsed.find_first_of (SLASH);
		if (end == ONE || end == TWO) {
			date = inputToBeParsed.substr (ZERO, end);
			if (isInteger (date)) {
				dateInt = convertStringToInteger (date);
				if (dateInt < ONE || dateInt > THIRTY_ONE) {
					throw ERROR_MESSAGE_DATE;
				}

				inputToBeParsed = inputToBeParsed.substr (end + ONE);
				end = inputToBeParsed.find_first_of(SPACE_SLASH);
				if (end == ONE || end == TWO ||
					(end == string::npos && 
					(inputToBeParsed.size() == ONE || inputToBeParsed.size () == TWO))) {
						month = inputToBeParsed.substr (ZERO, end);
						if (isInteger (month)) {
							monthInt= convertStringToInteger (month);
							if (monthInt < ONE || monthInt > TWELVE) {
								throw ERROR_MESSAGE_DATE;
							}

							if ((monthInt == FOUR || monthInt == SIX ||
								monthInt == NINE || monthInt == ELEVEN) &&
								dateInt == THIRTY_ONE) {
									throw ERROR_MESSAGE_DATE;
							}
							if (monthInt == TWO &&
								(dateInt == THIRTY || dateInt == THIRTY_ONE)) {
									throw ERROR_MESSAGE_DATE;
							}
							if (monthInt == TWO) {
								int year;
								if (isYearNumber (inputToBeParsed, year) &&
									!isLeapYear (year) &&
									dateInt == TWENTY_NINE) {
										throw ERROR_MESSAGE_DATE;
								}
								if (!isYearNumber (inputToBeParsed, year)) {
									TimeMacro timeMacro;
									getTodayDate (timeMacro);
									year = timeMacro.getYear();
									if (!isLeapYear (year) &&
										dateInt == TWENTY_NINE) {
											throw ERROR_MESSAGE_DATE;
									}
								}
							}
							return true;
						}
				}
			}
		}
	}

	return false;
}


//This method checks if the date format includes a year.
//If the date and month are followed by "/yyyy",
//it returns true;
//else, it returns false
bool Parser::isYearNumber (string inputToBeParsed, int& yearInt) {
	int end;
	string year;

	end = inputToBeParsed.find_first_of (SLASH);
	if (end == ONE || end == TWO) {
		year = inputToBeParsed.substr (end + ONE, FOUR);
		if (isInteger (year)) {
			yearInt = convertStringToInteger (year);
			if (yearInt < YEAR_MIN || yearInt > YEAR_MAX) {
				throw ERROR_MESSAGE_YEAR;
			}
			return true;
		}
	}

	return false;
}


//This method is to check if the start of the string is a date.
//This method only checks for date and month.
//The format is date (integer) 
//followed by month (abbreviation, the first alphabet can be both capital or small)
//eg. 21 Mar or 21 mar.
//The string firstly needs to be longer than the date format.
bool Parser::isDateAlphabet (string inputToBeParsed, int& dateInt) {
	int end;
	string date;
	string month;
	vector<string> monthList;
	monthList.push_back (JAN_CAP);
	monthList.push_back (FEB_CAP);
	monthList.push_back (MAR_CAP);
	monthList.push_back (APR_CAP);
	monthList.push_back (MAY_CAP);
	monthList.push_back (JUN_CAP);
	monthList.push_back (JUL_CAP);
	monthList.push_back (AUG_CAP);
	monthList.push_back (SEP_CAP);
	monthList.push_back (OCT_CAP);
	monthList.push_back (NOV_CAP);
	monthList.push_back (DEC_CAP);
	monthList.push_back (JAN_SMALL);
	monthList.push_back (FEB_SMALL);
	monthList.push_back (MAR_SMALL);
	monthList.push_back (APR_SMALL);
	monthList.push_back (MAY_SMALL);
	monthList.push_back (JUN_SMALL);
	monthList.push_back (JUL_SMALL);
	monthList.push_back (AUG_SMALL);
	monthList.push_back (SEP_SMALL);
	monthList.push_back (OCT_SMALL);
	monthList.push_back (NOV_SMALL);
	monthList.push_back (DEC_SMALL);

	if (inputToBeParsed.size() >= LENGTH_OF_DATE_ALPHABET) {
		end = inputToBeParsed.find_first_of (SPACE);
		if (end == ONE || end == TWO) {
			date = inputToBeParsed.substr (ZERO, end);
			if (isInteger (date)) {
				dateInt = convertStringToInteger (date);
				if (dateInt < ONE || dateInt > THIRTY_ONE) {
					throw ERROR_MESSAGE_DATE;
				}

				inputToBeParsed = inputToBeParsed.substr (end + ONE);
				month = inputToBeParsed.substr (ZERO, THREE);
				if (isStringEqual (month, monthList)) {
					if ((month == APR_CAP || month == APR_SMALL ||
						month == JUN_CAP || month == JUN_SMALL ||
						month == SEP_CAP || month == SEP_SMALL ||
						month == NOV_CAP || month == NOV_SMALL) &&
						dateInt == THIRTY_ONE) {
							throw ERROR_MESSAGE_DATE;
					}
					else if ((month == FEB_CAP || month == FEB_SMALL) &&
						(dateInt == THIRTY_ONE || dateInt == THIRTY)) {
							throw ERROR_MESSAGE_DATE;
					}
					return true;
				}
			}
		}
	}

	return false;
}


//This method checks if the date format includes a year.
//If the date and month are followed by " yyyy",
//it returns true;
//else, it returns false
bool Parser::isYearAlphabet (string inputToBeParsed, int& yearInt) {
	int end = 0;
	string year;
	if (inputToBeParsed.size() >= LENGTH_OF_YEAR_ALPHABET) {
		end = inputToBeParsed.find_first_of (SPACE);
		if (end == ZERO) {
			year = inputToBeParsed.substr (end + ONE, FOUR);
			if (isInteger (year)) {
				yearInt = convertStringToInteger (year);
				if (yearInt > YEAR_MAX || yearInt < YEAR_MIN) {
					throw ERROR_MESSAGE_YEAR;
				}
				return true;
			}
		}
	}

	return false;
}


//This method is to check if the start of the string is a starting time
//(which may be followed by an ending time).
//The string firstly needs to be longer than the time format.
//Then it must follow the format "hh:mm" or "h:mm"
//in order to be recognised as a starting time.
bool Parser::isStartingTimeTwentyFour (string inputToBeParsed, int& hourInt, int& minuteInt) {
	int end = 0;
	string hour;
	string minute;

	if (inputToBeParsed.size() >= LENGTH_OF_STARTING_TIME) {
		end = inputToBeParsed.find_first_of (COLON);
		if (end == ONE || end == TWO) {
			hour = inputToBeParsed.substr (ZERO, end);
			if (isInteger (hour)) {
				hourInt = convertStringToInteger (hour);
				if (hourInt < ZERO || hourInt > TWENTY_THREE) {
					throw ERROR_MESSAGE_TIME;
				}

				inputToBeParsed = inputToBeParsed.substr (end + ONE);
				minute = inputToBeParsed.substr (ZERO, TWO);
				if (isInteger (minute)) {
					minuteInt = convertStringToInteger (minute);
					if (minuteInt < ZERO || minuteInt > FIFTY_NINE) {
						throw ERROR_MESSAGE_TIME;
					}
					return true;
				}
			}
		}
	}

	return false;
}


//This method is to check if the start of the string is a time period.
//The string firstly needs to be longer than the time period format.
//Then it must follow the format "hh:mm-hh:mm", "h:mm-h:mm",
//"h:mm-hh:mm", or "hh:mm-h:mm"
//in order to be recognised as a time period.
bool Parser::isTimePeriodTwentyFour (string inputToBeParsed, int& hourBegInt, int& hourEndInt, 
		int& minuteBegInt, int& minuteEndInt) {
	int end = 0;
	if (inputToBeParsed.size() >= LENGTH_OF_TIME_PERIOD) {
		if (isStartingTimeTwentyFour (inputToBeParsed, hourBegInt, minuteBegInt)) {
			end = inputToBeParsed.find_first_of (DASH);
			if (end == FOUR || end == FIVE) {
				inputToBeParsed = inputToBeParsed.substr (end + ONE);
				if (isStartingTimeTwentyFour (inputToBeParsed, hourEndInt, minuteEndInt)) {
					return true;
				}
			}
		}
	}

	return false;
}


//This method is to check if the start of the string is a starting time
//(which may be followed by an ending time).
//The string firstly needs to be longer than the time format.
//Then it must follow the format "h", "hh", "h.mm", or "hh.mm"
//followed by "am" or "pm"
//in order to be recognised as a starting time.
bool Parser::isStartingTimeTwelve (string inputToBeParsed, int& hourInt, int& minuteInt) {
	int end = 0;
	string hour;
	string minute;

	if (inputToBeParsed.size () >= SIX) {  //"9.00am"
		end = inputToBeParsed.find_first_of (DOT);
		if (end == ONE || end == TWO) { //case 9.00am or 09.00am
			hour = inputToBeParsed.substr (ZERO, end);
			if (isInteger (hour)) {
				hourInt = convertStringToInteger (hour);
				if (hourInt < ONE || hourInt > TWELVE) {
					throw ERROR_MESSAGE_TIME;
				}

				minute = inputToBeParsed.substr (end + ONE, TWO);
				if (isInteger (minute)) {
					minuteInt = convertStringToInteger (minute);
					if (minuteInt < ZERO || minuteInt > FIFTY_NINE) {
						throw ERROR_MESSAGE_TIME;
					}

					if (inputToBeParsed.substr (end + THREE, TWO) == AM ||
						inputToBeParsed.substr (end + THREE, TWO) == PM) {
							if (inputToBeParsed.substr (end + THREE, TWO) == AM) {
								if (hourInt == TWELVE) {
									hourInt = ZERO;
								}
							}

							else {
								if (hourInt <= ELEVEN && hourInt >= ONE) {
									hourInt += TWELVE;
								}
							}
								return true;
					}
				}
			}
		}
	}

	if (inputToBeParsed.size () >= THREE) {  //"9am"
		end = inputToBeParsed.find_first_of (M);
		if (end == TWO || end == THREE) { //case 9am or 19am
			hour = inputToBeParsed.substr (ZERO, end - ONE);
			if (isInteger (hour)) {
				hourInt = convertStringToInteger (hour);
				if (hourInt < ONE || hourInt > TWELVE) {
					throw ERROR_MESSAGE_TIME;
				}
				minuteInt = ZERO;

				if (inputToBeParsed.substr (end - ONE, TWO) == AM ||
					inputToBeParsed.substr (end - ONE, TWO) == PM) {
						if (inputToBeParsed.substr (end - ONE, TWO) == AM) {
							if (hourInt == TWELVE) {
								hourInt = ZERO;
							}
						}
							
						else {
							if (hourInt <= ELEVEN && hourInt >= ONE) {
								hourInt += TWELVE;
							}
						}
							
						return true;
				}
			}
		}
	}

	return false;
}


//This method is to check if the start of the string is a time period.
//The string firstly needs to be longer than the time period format.
//Then it must follow the format "h", "hh", "h.mm", or "hh.mm"
//followed by "am" or "pm"
//in order to be recognised as a time period.
bool Parser::isTimePeriodTwelve (string inputToBeParsed,  int& hourBegInt, int& hourEndInt, 
		int& minuteBegInt, int& minuteEndInt) {
	int end = 0;
	if (inputToBeParsed.size() >= SEVEN ) { //9am-9pm
		if (isStartingTimeTwelve (inputToBeParsed, hourBegInt, minuteBegInt)) {
			end = inputToBeParsed.find_first_of (DASH);
			if (end == THREE || end == FOUR ||
				end ==SIX || end == SEVEN) {
					inputToBeParsed = inputToBeParsed.substr (end + ONE);
					if (isStartingTimeTwelve (inputToBeParsed, hourEndInt, minuteEndInt)) {
						return true;
					}
			}
		}
	}

	return false;
}


//This method checks if a vector contains certain string.
bool Parser::isStringEqual (string inputString, vector<string> compString) {
	for (int i = 0; i != compString.size(); i++) {
		if (inputString == compString [i]) {
			return true;
		}
	}
	return false;
}


//This method is to month in alphabet format to integer format.
int Parser::convertAlphabetMonthToInteger (string month) {
	int monthInt;
	if (month == JAN_CAP || month == JAN_SMALL) {
		monthInt = ONE;
	}
	else if (month == FEB_CAP || month == FEB_SMALL) {
		monthInt = TWO;
	}
	else if (month == MAR_CAP || month == MAR_SMALL) {
		monthInt = THREE;
	}
	else if (month == APR_CAP || month == APR_SMALL) {
		monthInt = FOUR;
	}
	else if (month == MAY_CAP || month == MAY_SMALL) {
		monthInt = FIVE;
	}
	else if (month == JUN_CAP || month == JUN_SMALL) {
		monthInt = SIX;
	}
	else if (month == JUL_CAP || month == JUL_SMALL) {
		monthInt = SEVEN;
	}
	else if (month == AUG_CAP || month == AUG_SMALL) {
		monthInt = EIGHT;
	}
	else if (month == SEP_CAP || month == SEP_SMALL) {
		monthInt = NINE;
	}
	else if (month == OCT_CAP || month == OCT_SMALL) {
		monthInt = TEN;
	}
	else if (month == NOV_CAP || month == NOV_SMALL) {
		monthInt = ELEVEN;
	}
	else if (month == DEC_CAP || month == DEC_SMALL) {
		monthInt = TWELVE;
	}
	return monthInt;
}

//This method takes in date, month and year
//and convert them to day of the week.
//Day of the week in the Data object will be updated.
string Parser::convertDateToDayOfTheWeek (int date, int month, int year) {
  time_t rawtime;
  struct tm timeinfo;
  const char* weekday[] = {SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
	  THURSDAY, FRIDAY, SATURDAY};

  time ( &rawtime );
  localtime_s (&timeinfo, &rawtime);
  timeinfo.tm_year = year - START_OF_YEAR;
  timeinfo.tm_mon = month - ONE;
  timeinfo.tm_mday = date;

  mktime ( &timeinfo );

  return (weekday[timeinfo.tm_wday]);
}


//This method is to get today's date, month, year and day
//and store them in a TimeMacro object
//which its caller can access.
void Parser::getTodayDate (TimeMacro& timeMacro) {
    time_t t = time (ZERO);   // get time now
    struct tm now;
	localtime_s (&now, &t);
    now.tm_year = now.tm_year + START_OF_YEAR;
    now.tm_mon = now.tm_mon + ONE;
	string dayOfTheWeek = convertDateToDayOfTheWeek (now.tm_mday, now.tm_mon, now.tm_year);
	
	timeMacro.updateYear (now.tm_year);
	timeMacro.updateMonth (now.tm_mon);
	timeMacro.updateDate (now.tm_mday);
	timeMacro.updateDay (dayOfTheWeek);
}


//This method is to get tomorrow's date, month, year and day
//and store them in a TimeMacro object
//which its caller can access.
void Parser::getTomorrowDate (TimeMacro& timeMacro) {
	TimeMacro today;
	getTodayDate (today);
	int date = today.getDate();
	int month = today.getMonth();
	int year = today.getYear();

	if (date == THIRTY_ONE) {
		if (month == TWELVE) {
			year += ONE;
			month = ONE;
		}
		else {
			month += ONE;
		}
		date = ONE;
	}
	else if (date == THIRTY) {
		if (month == FOUR || month == SIX ||
			month == NINE || month == ELEVEN) {
				date = ONE;
				month += ONE;
		}
	}
	else if (date == TWENTY_EIGHT && !isLeapYear (year) &&
		month == TWO) {
			date = ONE;
			month += ONE;
	}
	else if (date == TWENTY_NINE && isLeapYear (year) &&
		month ==TWO) {
			date = ONE;
			month += ONE;
	}
	else {
		date += ONE;
	}

	string dayOfTheWeek = convertDateToDayOfTheWeek (date, month, year);
    timeMacro.updateYear (year);
	timeMacro.updateMonth (month);
	timeMacro.updateDate (date);
	timeMacro.updateDay (dayOfTheWeek);
}


//This method is to get this Monday's date, month, year and day
//and store them in a TimeMacro object
//which its caller can access.
void Parser::getMondayDate (TimeMacro &timeMacro) {
	int day;
	int date;
	time_t t = time (ZERO);   
    struct tm now;
	localtime_s (&now, &t);
    now.tm_year = now.tm_year + START_OF_YEAR;
    now.tm_mon = now.tm_mon + ONE;

	if (now.tm_wday == ZERO) {
		day = SIX;
	}
	else {
		day = now.tm_wday - ONE;
	}
	date = now.tm_mday - day;

	if (date < ONE) {  //if Monday is on previous month
		if (now.tm_mon == ZERO) {   //if it is Jan now
			date += THIRTY_ONE;
			timeMacro.updateMonth (TWELVE);
			timeMacro.updateYear (now.tm_year - ONE);
		}
		else {
			timeMacro.updateMonth (now.tm_mon - ONE);
			timeMacro.updateYear (now.tm_year);
			if (now.tm_mon == ONE ||
				now.tm_mon == THREE ||
				now.tm_mon == FIVE ||
				now.tm_mon == SEVEN ||
				now.tm_mon ==EIGHT ||
				now.tm_mon == TEN) {  //Feb, Apr, Jun, Aug, Sep, Nov
				date += THIRTY_ONE;
			}
			else if (now.tm_mon == TWO) {  //Mar
				if (isLeapYear (now.tm_year)) {
					date += TWENTY_NINE;
				}
				else {
					date += TWENTY_EIGHT;
				}
			}
			else if (now.tm_mon == FOUR ||
				now.tm_mon == SIX ||
				now.tm_mon == NINE ||
				now.tm_mon == ELEVEN) {  //May, Jul, Oct, Dec
				date += THIRTY;
			}
		}
	}
	else {
		timeMacro.updateMonth (now.tm_mon);
		timeMacro.updateYear (now.tm_year);
	}

	timeMacro.updateDate (date);
	timeMacro.updateDay (MONDAY);

}


//This method is to get this Sunday's date, month, year and day
//and store them in a TimeMacro object
//which its caller can access.
void Parser::getSundayDate (TimeMacro &timeMacro) {
	int day;
	int date;
	time_t t = time (ZERO);   
    struct tm now;
	localtime_s (&now, &t);
    now.tm_year = now.tm_year + START_OF_YEAR;
    now.tm_mon = now.tm_mon + ONE;

	if (now.tm_wday == ZERO) {
		day = ZERO;
	}
	else {
		day = SEVEN - now.tm_wday;
	}
	date = now.tm_mday + day;

	if (now.tm_mon != ELEVEN || date <= THIRTY_ONE) { //not end of Dec
		timeMacro.updateYear (now.tm_year);
		if ((now.tm_mon == ZERO || //Jan, Mar, May, Jul, Aug, Oct
			now.tm_mon == TWO ||
			now.tm_mon == FOUR ||
			now.tm_mon == SIX ||
			now.tm_mon == SEVEN ||
			now.tm_mon == NINE) && 
			date > THIRTY_ONE) {
				date -= THIRTY_ONE;
				timeMacro.updateMonth (now.tm_mon + 1);
		}

		else if ((now.tm_mon == THREE ||  //Apr, Jun, Sep, Nov
			now.tm_mon == FIVE ||
			now.tm_mon == EIGHT ||
			now.tm_mon == TEN) &&
			date > THIRTY) {
				date -= THIRTY;
				timeMacro.updateMonth (now.tm_mon + ONE);
		}

		else if (now.tm_mon == ONE &&  //Feb
			isLeapYear (now.tm_year) && date > TWENTY_NINE) {
				date -= TWENTY_NINE;
				timeMacro.updateMonth (now.tm_mon + ONE);
		}
		else if (now.tm_mon == ONE &&
			!isLeapYear (now.tm_year) && date > TWENTY_EIGHT) {
				date -= TWENTY_EIGHT;
				timeMacro.updateMonth (now.tm_mon + ONE);
		}

		else {
			timeMacro.updateMonth (now.tm_mon);
		}
	}
	else {
		date -= THIRTY_ONE;
		timeMacro.updateYear (now.tm_year + ONE);
		timeMacro.updateMonth (ZERO);
	}


	timeMacro.updateDate (date);
	timeMacro.updateDay (SUNDAY);
}


//This method is to get the starting date and ending date
//of this month.
//The starting and ending date, month and year
//will be stored in two TimeMacro objects
//which will be passed to its caller.
//Please no
void Parser::getThisMonth (TimeMacro& timeMacroBeg, TimeMacro& timeMacroEnd) {
	time_t t = time (ZERO);
    struct tm now;
	localtime_s (&now, &t);
    now.tm_year = now.tm_year + START_OF_YEAR;
    now.tm_mon = now.tm_mon + ONE;

	timeMacroBeg.updateYear (now.tm_year);
	timeMacroBeg.updateMonth (now.tm_mon);
	timeMacroBeg.updateDate (ONE);

	timeMacroEnd.updateYear (now.tm_year);
	timeMacroEnd.updateMonth (now.tm_mon);

	if (now.tm_mon == ONE || now.tm_mon == THREE ||
		now.tm_mon == FIVE || now.tm_mon == SEVEN ||
		now.tm_mon == EIGHT || now.tm_mon == TEN ||
		now.tm_mon == TWELVE) {
			timeMacroEnd.updateDate (THIRTY_ONE);
	}
	else if (now.tm_mon == FOUR || now.tm_mon == SIX ||
		now.tm_mon == NINE || now.tm_mon == ELEVEN) {
			timeMacroEnd.updateDate (THIRTY);
	}
	else if (now.tm_mon == TWO && isLeapYear (now.tm_year)) {
		timeMacroEnd.updateDate (TWENTY_NINE);
	}
	else {
		timeMacroEnd.updateDate (TWENTY_EIGHT);
	}	
}

//One potential bug:
//the date period must be the start and end of this month
//there may be bug when the ending date of month changes


//This method is to check if a certain year is a leap year or not
bool Parser::isLeapYear (int year) {
	if (year % FOUR != ZERO) {
		return false;
	}
	else if (year % HUNDRAD != ZERO) {
		return true;
	}
	else if (year % FOUR_HUNDRAD != ZERO) {
		return false;
	}
	else {
		return true;
	}
}
	// End of segment: C:\Users\Yang\Desktop\Projects\main\Parser\Parser.cpp





	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\Parser\Parser.h
	 */

#ifndef PARSER_H
#define PARSER_H
#include <iostream>
#include <string>
#include <time.h>
#include <vector>
#include <assert.h>
#include "Commons.h"

using namespace std;

class Parser {
private: 

	//private attributes
	string _command;
	Data _myData;
	int _taskNo;
	string _errorMessage;
	string _directory;


	//setters
	void updateCommand (string commandWord) {
		_command = commandWord;
	}

	void updateTaskNo (int taskNo) {
		_taskNo = taskNo;
	}

	void updateTimeMicro (TimeMicro timeMicro) {
		_myData.updateTimeMicroBeg (timeMicro);
	}

	void updateTimeMicroPeriod (TimeMicro timeMicroBeg, TimeMicro timeMicroEnd) {
		_myData.updateTimeMicroBeg (timeMicroBeg);
		_myData.updateTimeMicroEnd (timeMicroEnd);
	}

	void updateTimeMacro (TimeMacro timeMacro) {
		_myData.updateTimeMacroBeg (timeMacro);
	}

	void updateTimeMacroPeriod (TimeMacro timeMacroBeg, TimeMacro timeMacroEnd) {
		_myData.updateTimeMacroBeg (timeMacroBeg);
		_myData.updateTimeMacroEnd (timeMacroEnd);
	}

	void updateDesc (string desc) {
		_myData.updateDesc (desc);
	}

	void updateErrorMessage (string errorMessage) {
		_errorMessage = errorMessage;
	}

	void updateStatus (bool status) {
		_myData.updateCompleteStatus (status);
	}

	void updateDirectory (string directory) {
		_directory = directory;
	}
	

	//private static variables
	static const unsigned int LENGTH_OF_DATE_NUMBER;
	static const unsigned int LENGTH_OF_DATE_ALPHABET;
	static const unsigned int LENGTH_OF_YEAR_ALPHABET;
	static const unsigned int LENGTH_OF_STARTING_TIME;
	static const unsigned int LENGTH_OF_TIME_PERIOD;
	static const unsigned int START_OF_YEAR;
	static const unsigned int YEAR_MIN;
	static const unsigned int YEAR_MAX;

	static const unsigned int ZERO;
	static const unsigned int ONE;
	static const unsigned int TWO;
	static const unsigned int THREE;
	static const unsigned int FOUR;
	static const unsigned int FIVE;
	static const unsigned int SIX;
	static const unsigned int SEVEN;
	static const unsigned int EIGHT;
	static const unsigned int NINE;
	static const unsigned int TEN;
	static const unsigned int ELEVEN;
	static const unsigned int TWELVE;
	static const unsigned int TWENTY_THREE;
	static const unsigned int TWENTY_EIGHT;
	static const unsigned int TWENTY_NINE;
	static const unsigned int THIRTY;
	static const unsigned int THIRTY_ONE;
	static const unsigned int FIFTY_NINE;
	static const unsigned int HUNDRAD;
	static const unsigned int FOUR_HUNDRAD;
	static const char AM[100];
	static const char PM[100];
	static const char M[100];
	
	static const unsigned int TIMEMICRO_INITIAL;
	static const char EMPTY_STRING[100];
	static const char SPACE[100];
	static const char SLASH[100];
	static const char SPACE_SLASH[100];
	static const char COLON[100];
	static const char DOT[100];
	static const char DASH[100];
	
	static const char JAN_CAP[100];
	static const char FEB_CAP[100];
	static const char MAR_CAP[100];
	static const char APR_CAP[100];
	static const char MAY_CAP[100];
	static const char JUN_CAP[100];
	static const char JUL_CAP[100];
	static const char AUG_CAP[100];
	static const char SEP_CAP[100];
	static const char OCT_CAP[100];
	static const char NOV_CAP[100];
	static const char DEC_CAP[100];
	static const char JAN_SMALL[100];
	static const char FEB_SMALL[100];
	static const char MAR_SMALL[100];
	static const char APR_SMALL[100];
	static const char MAY_SMALL[100];
	static const char JUN_SMALL[100];
	static const char JUL_SMALL[100];
	static const char AUG_SMALL[100];
	static const char SEP_SMALL[100];
	static const char OCT_SMALL[100];
	static const char NOV_SMALL[100];
	static const char DEC_SMALL[100];

	static const char MONDAY[100];
	static const char TUESDAY[100];
	static const char WEDNESDAY[100];
	static const char THURSDAY[100];
	static const char FRIDAY[100];
	static const char SATURDAY[100];
	static const char SUNDAY[100];

	static const char COMMAND_ADD[100];
	static const char COMMAND_EDIT[100];
	static const char COMMAND_SEARCH[100];
	static const char COMMAND_UNDO[100];
	static const char COMMAND_DELETE[100];
	static const char COMMAND_DONE[100];
	static const char COMMAND_UNDONE[100];
	static const char COMMAND_SHOW[100];
	static const char COMMAND_CLEAR[100];
	static const char COMMAND_PATH[100];
	static const char COMMAND_HELP[100];
	static const char COMMAND_TODAY[100];
	static const char COMMAND_TOMORROW[100];
	static const char COMMAND_THIS_WEEK[100];
	static const char COMMAND_THIS_MONTH[100];
	static const char COMMAND_COMMANDS[100];
	static const char COMMAND_FLOAT[100];
	static const char COMMAND_FEATURES[100];

	static const char ERROR_MESSAGE_COMMAND[100];
	static const char ERROR_MESSAGE_INPUT[100];
	static const char ERROR_MESSAGE_EDIT[100];
	static const char ERROR_MESSAGE_TASK_NO[100];
	static const char ERROR_MESSAGE_SHOW[100];
	static const char ERROR_MESSAGE_DIRECTORY[100];
	static const char ERROR_MESSAGE_DATE[100];
	static const char ERROR_MESSAGE_YEAR[100];
	static const char ERROR_MESSAGE_TIME[100];
	static const char ERROR_MESSAGE_DESC[100];

	static const char LOG_START[100];
	static const char LOG_SUCCESS[100];
	static const char LOG_ERROR[100];

	
public:

	//default constructor
	Parser () {}


	//getters
	string Parser::getCommand () {
		return _command;
	}

	int Parser::getTaskNo () {
		return _taskNo;
	}

	Data getData () {
		return _myData;
	}

	string getErrorMessage () {
		return _errorMessage;
	}

	string getDirectory () {
		return _directory;
	}


	//API for OperationCenter to access
	void parseInput (string userInput);
	
	//public methods
	string extractCommandWord (string userInput);
	void checkCommandWord (string userInput, string commandWord);
	void parseAdd (string userInput, string commandWord);
	void parseEdit (string userInput, string commandWord);
	void parseSearch (string userInput, string commandWord);
	void parseUndo (string userInput, string commandWord);
	void parseDelete (string userInput, string commandWord);
	void parseDone (string userInput, string commandWord);
	void parseUndone (string userInput, string commandWord);
	void parseShow (string userInput, string commandWord);
	void parseClear (string userInput, string commandWord);
	void parsePath (string userInput, string commandWord);
	void parseHelp (string userInput, string commandWord);
    void parseDateNumber (string& inputToBeParsesd, TimeMacro& timeMacro);
	void parseDateAlphabet (string& inputToBeParsesd, TimeMacro& timeMacro);
	void parseTimeTwentyFour (string& inputToBeParsed, TimeMicro& timeMicroBeg, TimeMicro& timeMicroEnd);
	void parseTimeTwelve (string& inputToBeParsed, TimeMicro& timeMicroBeg, TimeMicro& timeMicroEnd);
	string parseTaskNo (string inputToBeParsed);
	bool isInteger (string index);
	int convertStringToInteger (string index);
	bool isDateNumber (string inputToBeParsed, int& dateInt, int& monthInt);
	bool isYearNumber (string inputToBeParsed, int& yearInt);
	bool isDateAlphabet (string inputToBeParsed, int& dateInt);
	bool isYearAlphabet (string inputToBeParsed, int& yearInt);
	string convertDateToDayOfTheWeek (int date, int month, int year);
	bool isStartingTimeTwentyFour (string inputToBeParsed, int& hourInt, int& minuteInt);
	bool isTimePeriodTwentyFour (string inputToBeParsed, int& hourBegInt, int& hourEndInt, 
		int& minuteBegInt, int& minuteEndInt);
	bool isStartingTimeTwelve (string inputToBeParsed, int& hourInt, int& minuteInt);
	bool isTimePeriodTwelve (string inputToBeParsed, int& hourBegInt, int& hourEndInt, 
		int& minuteBegInt, int& minuteEndInt);
	bool isStringEqual (string inputString, vector<string> compString);
	int convertAlphabetMonthToInteger (string month);
	void getTodayDate (TimeMacro& timeMacro);
	void getTomorrowDate (TimeMacro& timeMacro);
	void getMondayDate (TimeMacro& timeMacro);
	void getSundayDate (TimeMacro& timeMacro);
	void getThisMonth (TimeMacro& timeMacroBeg, TimeMacro& timeMacroEnd);
	bool isLeapYear (int year);
	

};
#endif
	// End of segment: C:\Users\Yang\Desktop\Projects\main\Parser\Parser.h





	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\testHistory\stdafx.h
	 */

#include "InternalStoring.h"
#include "Storing.h"
// TODO: reference additional headers your program requires here

	// End of segment: C:\Users\Yang\Desktop\Projects\main\testHistory\stdafx.h





	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\testHistory\unittest1.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace testHistory
{		
	TEST_CLASS(testHistory)
	{
	public:
		
		TEST_METHOD(testLatestCommand)
		{
			History::updateLatestCommand ("add");
			std::string expectedOutput = "add";
			Assert::AreEqual (History::getLatestCommand(), expectedOutput);
		}

		TEST_METHOD(testLatestData)
		{
			Data myData;
			TimeMacro timeMacro;
			TimeMicro timeMicro;
			timeMacro.updateDate (5);
			timeMicro.updateHour (6);
			myData.updateDesc ("breakfast");
			myData.updateTaskNo (3);
			myData.updateTimeMicroBeg (timeMicro);
			myData.updateTimeMacroEnd (timeMacro);

			History::updateLatestData (myData);
			History::getLatestData ();


			std::string expectedDesc = "breakfast";
			Assert::AreEqual ((History::getLatestData ()).getDesc (), expectedDesc);
			Assert::AreEqual ((History::getLatestData ()).getTaskNo (), 3);
			Assert::AreEqual ((History::getLatestData ()).getTimeMicroBeg ().getHour (), 6);
			Assert::AreEqual ((History::getLatestData ()).getTimeMacroEnd ().getDate (), 5);
		}
		

	};
}
	// End of segment: C:\Users\Yang\Desktop\Projects\main\testHistory\unittest1.cpp





	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\testParser\ParserUnitTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace testParser
{		
	TEST_CLASS(testParser)
	{
	public:
		
		//To test whether can extract "add" command
		TEST_METHOD(testExtractCommand)
		{
			Parser parser;
			string testString = "add 08/03/2015 go for tutorial";
			string expected = "add";
			Assert::AreEqual (parser.extractCommandWord (testString), expected);
		}

		//To test for invalid command
		TEST_METHOD(testInvalidCommand)
		{
			Parser parser;
			string testString = "abc";
			string expected = "Please enter the correct command";
			parser.parseInput (testString);
			Assert::AreEqual (parser.getErrorMessage(), expected);
		}

		//To test for a leap year
		TEST_METHOD(testIsLeapYear1)
		{
			Parser parser;
			int year = 2004;
			Assert::IsTrue (parser.isLeapYear (year));
		}

		//To test for a non-leap year
		TEST_METHOD(testIsNotLeapYear)
		{
			Parser parser;
			int year = 2015;
			Assert::IsFalse (parser.isLeapYear (year));
		}

		//To test for a leap year which can be divided by 400
		TEST_METHOD(testIsLeapYear2)
		{
			Parser parser;
			int year = 2000;
			Assert::IsTrue (parser.isLeapYear (year));
		}

		//To test whether a string is contained in a vector.
		//In this case, it is contained in the vector.
		TEST_METHOD(testStringEqual)
		{
			Parser parser;
			string string = "abc";
			vector<std::string> stringVector;
			stringVector.push_back ("abc");
			stringVector.push_back ("def");
			Assert::IsTrue (parser.isStringEqual (string, stringVector));
		}

		//To test whether a string is contained in a vector.
		//In this case, it is not contained in the vector.
		TEST_METHOD(testStringNotEqual)
		{
			Parser parser;
			string string = "abc";
			vector<std::string> stringVector;
			stringVector.push_back ("abb");
			stringVector.push_back ("def");
			Assert::IsFalse (parser.isStringEqual (string, stringVector));
		}

		//To test whether can update and get today's date correctly
		TEST_METHOD(testTodayDate)
		{
			Parser parser;
			TimeMacro timeMacro;
			string dayOfTheWeek = "Friday";
			parser.getTodayDate (timeMacro);
			Assert::AreEqual (timeMacro.getDate(), 17);
			Assert::AreEqual (timeMacro.getMonth(), 4);
			Assert::AreEqual (timeMacro.getYear(), 2015);
			Assert::AreEqual (timeMacro.getDay(), dayOfTheWeek);
		}

		//To test whether a date can be converted to day of the week correctly
		TEST_METHOD(testConvertDateToDay)
		{
			Parser parser;
			TimeMacro timeMacro;
			string dayOfTheWeek = "Thursday";
			Assert::AreEqual (parser.convertDateToDayOfTheWeek (12, 3, 2015), dayOfTheWeek);
		}

		//To test whether a string can be converted to an integer
		//The boundary case is 1
		TEST_METHOD(testConvertStringToInteger)
		{
			Parser parser;
			string index = "1";			
			Assert::AreEqual (parser.convertStringToInteger (index), 1);
		}

		//To test whether a string can be converted to a month
		TEST_METHOD(testConvertStringToMonthJanCap)
		{
			Parser parser;
			string month = "Jan";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 1);
		}

		TEST_METHOD(testConvertStringToMonthJanSmall)
		{
			Parser parser;
			string month = "jan";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 1);
		}

		TEST_METHOD(testConvertStringToMonthFebCap)
		{
			Parser parser;
			string month = "Feb";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 2);
		}

		TEST_METHOD(testConvertStringToMonthFebSmall)
		{
			Parser parser;
			string month = "feb";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 2);
		}

		TEST_METHOD(testConvertStringToMonthMarCap)
		{
			Parser parser;
			string month = "Mar";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 3);
		}

		TEST_METHOD(testConvertStringToMonthMarSmall)
		{
			Parser parser;
			string month = "mar";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 3);
		}

		TEST_METHOD(testConvertStringToMonthAprCap)
		{
			Parser parser;
			string month = "Apr";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 4);
		}

		TEST_METHOD(testConvertStringToMonthAprSmall)
		{
			Parser parser;
			string month = "apr";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 4);
		}

		TEST_METHOD(testConvertStringToMonthMayCap)
		{
			Parser parser;
			string month = "May";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 5);
		}

		TEST_METHOD(testConvertStringToMonthMaySamll)
		{
			Parser parser;
			string month = "may";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 5);
		}

		TEST_METHOD(testConvertStringToMonthJunCap)
		{
			Parser parser;
			string month = "Jun";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 6);
		}

		TEST_METHOD(testConvertStringToMonthJunSmall)
		{
			Parser parser;
			string month = "jun";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 6);
		}

		TEST_METHOD(testConvertStringToMonthJulCap)
		{
			Parser parser;
			string month = "Jul";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 7);
		}

		TEST_METHOD(testConvertStringToMonthJulSmall)
		{
			Parser parser;
			string month = "jul";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 7);
		}

		TEST_METHOD(testConvertStringToMonthAugCap)
		{
			Parser parser;
			string month = "Aug";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 8);
		}

		TEST_METHOD(testConvertStringToMonthAugSmall)
		{
			Parser parser;
			string month = "aug";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 8);
		}

		TEST_METHOD(testConvertStringToMonthSepCap)
		{
			Parser parser;
			string month = "Sep";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 9);
		}

		TEST_METHOD(testConvertStringToMonthSepSmall)
		{
			Parser parser;
			string month = "sep";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 9);
		}

		TEST_METHOD(testConvertStringToMonthOctCap)
		{
			Parser parser;
			string month = "Oct";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 10);
		}

		TEST_METHOD(testConvertStringToMonthOctSmall)
		{
			Parser parser;
			string month = "oct";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 10);
		}

		TEST_METHOD(testConvertStringToMonthNovCap)
		{
			Parser parser;
			string month = "Nov";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 11);
		}

		TEST_METHOD(testConvertStringToMonthNovSmall)
		{
			Parser parser;
			string month = "nov";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 11);
		}

		TEST_METHOD(testConvertStringToMonthDecCap)
		{
			Parser parser;
			string month = "Dec";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 12);
		}

		TEST_METHOD(testConvertStringToMonthDecCapSmall)
		{
			Parser parser;
			string month = "dec";	
			Assert::AreEqual (parser.convertAlphabetMonthToInteger (month), 12);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "hh:mm-hh:mm"
		//"00:00-23:59" is also the boundary case
		TEST_METHOD(testIsTimePeriodTwentyFour1)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "00:00-23:59";
			Assert::IsTrue (parser.isTimePeriodTwentyFour (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 0);
			Assert::AreEqual (hourEnd, 23);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 59);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "h:mm-hh:mm"
		//"0:00-23:59" is also the boundary case
		TEST_METHOD(testIsTimePeriodTwentyFour2)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "0:00-23:59";
			Assert::IsTrue (parser.isTimePeriodTwentyFour (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 0);
			Assert::AreEqual (hourEnd, 23);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 59);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "hh:mm-h:mm"
		TEST_METHOD(testIsTimePeriodTwentyFour3)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "00:00-9:59";
			Assert::IsTrue (parser.isTimePeriodTwentyFour (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 0);
			Assert::AreEqual (hourEnd, 9);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 59);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "h:mm-h:mm"
		TEST_METHOD(testIsTimePeriodTwentyFour4)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "0:00-9:59";
			Assert::IsTrue (parser.isTimePeriodTwentyFour (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 0);
			Assert::AreEqual (hourEnd, 9);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 59);
		}

		//To test whether a string is a time period
		//In this case, the string is not a time period but a starting time
		TEST_METHOD(testIsNotTimePeriodTwentyFour)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "09:00";
			Assert::IsFalse (parser.isTimePeriodTwentyFour (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
		}

		//To test whether a string is a starting time
		//The format is hh:mm
		//The boundary case is 00:00
		TEST_METHOD(testIsStartingTimeTwentyFour1)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "00:00";
			Assert::IsTrue (parser.isStartingTimeTwentyFour (testString, hour, minute));
			Assert::AreEqual (hour, 0);
			Assert::AreEqual (minute, 0);
		}

		//To test whether a string is a starting time
		//The format is hh:mm
		//The boundary case is 23:59
		TEST_METHOD(testIsStartingTimeTwentyFour2)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "23:59";
			Assert::IsTrue (parser.isStartingTimeTwentyFour (testString, hour, minute));
			Assert::AreEqual (hour, 23);
			Assert::AreEqual (minute, 59);
		}

		//To test whether a string is a starting time
		//The format is h:mm
		//The boundary case is 0:00
		TEST_METHOD(testIsStartingTimeTwentyFour3)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "0:00";
			Assert::IsTrue (parser.isStartingTimeTwentyFour (testString, hour, minute));
			Assert::AreEqual (hour, 0);
			Assert::AreEqual (minute, 0);
		}

		//To test whether a string is a starting time
		//The format is h:mm
		//The boundary case is 9:59
		TEST_METHOD(testIsStartingTimeTwentyFour4)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "9:59";
			Assert::IsTrue (parser.isStartingTimeTwentyFour (testString, hour, minute));
			Assert::AreEqual (hour, 9);
			Assert::AreEqual (minute, 59);
		}

		//To test whether a string is a starting time
		//In this case, the string is not a starting time but a date
		TEST_METHOD(testIsNotStartingTimeTwentyFour)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "12/03/2015 dinner tonight";
			Assert::IsFalse (parser.isStartingTimeTwentyFour (testString, hour, minute));
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "ham-hpm"
		TEST_METHOD(testIsTimePeriodTwelve1)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "1am-9pm";
			Assert::IsTrue (parser.isTimePeriodTwelve (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 1);
			Assert::AreEqual (hourEnd, 21);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 0);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "hham-hhpm"
		TEST_METHOD(testIsTimePeriodTwelve2)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "01am-12pm";
			Assert::IsTrue (parser.isTimePeriodTwelve (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 1);
			Assert::AreEqual (hourEnd, 12);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 0);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "h.mmam-h.mmpm"
		TEST_METHOD(testIsTimePeriodTwelve3)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "1.00am-9.59pm";
			Assert::IsTrue (parser.isTimePeriodTwelve (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 1);
			Assert::AreEqual (hourEnd, 21);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 59);
		}

		//To test whether a string is a time period
		//In this case, the string is a time period
		//with the format "hh.mmam-hh.mmpm"
		TEST_METHOD(testIsTimePeriodTwelve4)
		{
			Parser parser;
			int hourBeg;
			int hourEnd;
			int minuteBeg;
			int minuteEnd;
			string testString = "01.00am-12.59pm";
			Assert::IsTrue (parser.isTimePeriodTwelve (testString, hourBeg, hourEnd, 
				minuteBeg, minuteEnd));
			Assert::AreEqual (hourBeg, 1);
			Assert::AreEqual (hourEnd, 12);
			Assert::AreEqual (minuteBeg, 0);
			Assert::AreEqual (minuteEnd, 59);
		}

		//To test whether a string is a starting time
		//The boundary case is 01.00pm
		TEST_METHOD(testIsStartingTimeTwelve1)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "01.00pm";
			Assert::IsTrue (parser.isStartingTimeTwelve (testString, hour, minute));
			Assert::AreEqual (hour, 13);
			Assert::AreEqual (minute, 0);
		}

		//To test whether a string is a starting time
		//The boundary case is 12.59am
		TEST_METHOD(testIsStartingTimeTwelve2)
		{
			Parser parser;
			int hour;
			int minute;
			string testString = "12.59am";
			Assert::IsTrue (parser.isStartingTimeTwelve (testString, hour, minute));
			Assert::AreEqual (hour, 0);
			Assert::AreEqual (minute, 59);
		}

		//To test whether a string is a date
		//The format is dd/mm/yyyy
		//The boundary case is 01/01/2000
		TEST_METHOD(testIsDateNumber1)
		{
			Parser parser;
			int date;
			int month;
			string testString = "01/01/2000";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is dd/mm/yyyy
		//The boundary case is 31/12/2100
		TEST_METHOD(testIsDateNumber2)
		{
			Parser parser;
			int date;
			int month;
			string testString = "31/12/2100";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is d/mm/yyyy
		//The boundary case is 1/01/2000
		TEST_METHOD(testIsDateNumber3)
		{
			Parser parser;
			int date;
			int month;
			string testString = "1/01/2000";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is d/mm/yyyy
		//The boundary case is 9/12/2100
		TEST_METHOD(testIsDateNumber4)
		{
			Parser parser;
			int date;
			int month;
			string testString = "9/12/2100";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is dd/m/yyyy
		//The boundary case is 01/1/2000
		TEST_METHOD(testIsDateNumber5)
		{
			Parser parser;
			int date;
			int month;
			string testString = "01/1/2000";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is dd/m/yyyy
		//The boundary case is 30/9/2100
		TEST_METHOD(testIsDateNumber6)
		{
			Parser parser;
			int date;
			int month;
			string testString = "30/9/2100";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is d/m/yyyy
		//The boundary case is 1/1/2000
		TEST_METHOD(testIsDateNumber7)
		{
			Parser parser;
			int date;
			int month;
			string testString = "1/1/2000";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//The format is d/m/yyyy
		//The boundary case is 9/9/2100
		TEST_METHOD(testIsDateNumber8)
		{
			Parser parser;
			int date;
			int month;
			string testString = "9/9/2100";
			Assert::IsTrue (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a date
		//In this case, the string is not a date but a task description
		TEST_METHOD(testIsNotDateNumber)
		{
			Parser parser;
			int date;
			int month;
			string testString = "dinner tonight";
			Assert::IsFalse (parser.isDateNumber (testString, date, month));
		}

		//To test whether a string is a year
		//The format is "mm/yyyy"
		//The boundary case is "01/2000"
		TEST_METHOD(testIsYearNumber1)
		{
			Parser parser;
			int year;
			string testString = "01/2000";
			Assert::IsTrue (parser.isYearNumber (testString, year));
		}

		//To test whether a string is a year
		//The format is "mm/yyyy"
		//The boundary case is "12/2100"
		TEST_METHOD(testIsYearNumber2)
		{
			Parser parser;
			int year;
			string testString = "12/2100";
			Assert::IsTrue (parser.isYearNumber (testString, year));
		}

		//To test whether a string is a date
		//The format is dd MMM yyyy
		//The boundary case is 01 Jan 2000
		TEST_METHOD(testIsDateAlphabet1)
		{
			Parser parser;
			int date;
			string testString = "01 Jan 2000";
			Assert::IsTrue (parser.isDateAlphabet (testString, date));
		}

		//To test whether a string is a date
		//The format is dd MMM yyyy
		//The boundary case is 31 dec 2100
		TEST_METHOD(testIsDateAlphabet2)
		{
			Parser parser;
			int date;
			string testString = "31 dec 2100";
			Assert::IsTrue (parser.isDateAlphabet (testString, date));
		}

		//To test whether a string is a date
		//The format is d MMM yyyy
		//The boundary case is 1 Jan 2000
		TEST_METHOD(testIsDateAlphabet3)
		{
			Parser parser;
			int date;
			string testString = "1 Jan 2000";
			Assert::IsTrue (parser.isDateAlphabet (testString, date));
		}

		//To test whether a string is a year
		//The format is " yyyy"
		//The boundary case is 2000
		TEST_METHOD(testIsYearAlphabet1)
		{
			Parser parser;
			int year;
			string testString = " 2000";
			Assert::IsTrue (parser.isYearAlphabet (testString, year));
		}

		//To test whether a string is a year
		//The format is " yyyy"
		//The boundary case is 2100
		TEST_METHOD(testIsYearAlphabet2)
		{
			Parser parser;
			int year;
			string testString = " 2100";
			Assert::IsTrue (parser.isYearAlphabet (testString, year));
		}

		//To test whether can parse a task number
		TEST_METHOD(testParseTaskNo)
		{
			Parser parser;
			string testString = "3";
			string expected = "3";
			Assert::AreEqual (parser.parseTaskNo (testString), expected);
		}

		//To test whether can parse a time period
		TEST_METHOD(testParseTimeTwentyFourPeriod)
		{
			Parser parser;
			TimeMicro timeMicroBeg;
			TimeMicro timeMicroEnd;
			string testString = "00:00-23:59";
			parser.parseTimeTwentyFour (testString, timeMicroBeg, timeMicroEnd);
			Assert::AreEqual (timeMicroBeg.getHour(), 0);
			Assert::AreEqual (timeMicroBeg.getMin(), 0);
			Assert::AreEqual (timeMicroEnd.getHour(), 23);
			Assert::AreEqual (timeMicroEnd.getMin(), 59);
		}

		//To test whether can parse a starting time
		TEST_METHOD(testParseTimeTwentyFourStarting)
		{
			Parser parser;
			TimeMicro timeMicroBeg;
			TimeMicro timeMicroEnd;
			string testString = "00:00";
			parser.parseTimeTwentyFour (testString, timeMicroBeg, timeMicroEnd);
			Assert::AreEqual (timeMicroBeg.getHour(), 0);
			Assert::AreEqual (timeMicroBeg.getMin(), 0);
			Assert::AreEqual (timeMicroEnd.getHour(), -1);
			Assert::AreEqual (timeMicroEnd.getMin(), -1);
		}

		//To test whether can parse a time period
		TEST_METHOD(testParseTimeTwelvePeriod)
		{
			Parser parser;
			TimeMicro timeMicroBeg;
			TimeMicro timeMicroEnd;
			string testString = "1.00am-12.59pm";
			parser.parseTimeTwelve (testString, timeMicroBeg, timeMicroEnd);
			Assert::AreEqual (timeMicroBeg.getHour(), 1);
			Assert::AreEqual (timeMicroBeg.getMin(), 0);
			Assert::AreEqual (timeMicroEnd.getHour(), 12);
			Assert::AreEqual (timeMicroEnd.getMin(), 59);
		}

		//To test whether can parse a starting time
		TEST_METHOD(testParseTimeTwelveStarting)
		{
			Parser parser;
			TimeMicro timeMicroBeg;
			TimeMicro timeMicroEnd;
			string testString = "1.00pm";
			parser.parseTimeTwelve (testString, timeMicroBeg, timeMicroEnd);
			Assert::AreEqual (timeMicroBeg.getHour(), 13);
			Assert::AreEqual (timeMicroBeg.getMin(), 0);
			Assert::AreEqual (timeMicroEnd.getHour(), -1);
			Assert::AreEqual (timeMicroEnd.getMin(), -1);
		}

		//To test whether can update and get the "undo" command
		TEST_METHOD(testParseUndo)
		{
			Parser parser;
			string input = "undo";
			string commandWord = "undo";
			parser.parseUndo (input, commandWord);
			Assert::AreEqual (parser.getCommand (), commandWord);
		}

		//To test whether can parse for the "delete" feature
		//The boundary case is 1
		TEST_METHOD(testParseDelete)
		{
			Parser parser;
			string input = "delete 1";
			string commandWord = "delete";
			parser.parseDelete (input, commandWord);
			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getTaskNo (), 1);
		}

		//To test whether can update and get
		//date, month, year, day
		TEST_METHOD(testParseDateNumber)
		{
			Parser parser;
			TimeMacro timeMacro;
			string testString = "01/01/2000";
			string expectedDay = "Saturday";
			parser.parseDateNumber (testString, timeMacro);
			Assert::AreEqual (timeMacro.getDate (), 1);
			Assert::AreEqual (timeMacro.getMonth (), 1);
			Assert::AreEqual (timeMacro.getYear (), 2000);
			Assert::AreEqual (timeMacro.getDay (), expectedDay);
		}

		//To test whether can ignore it when parsing date
		//when the input string is a time period
		TEST_METHOD(testParseNotDateNumber)
		{
			Parser parser;
			TimeMacro timeMacro;
			string testString = "09:00-10:00";
			string expectedDay = "undefined";
			parser.parseDateNumber (testString, timeMacro);
			Assert::AreEqual (timeMacro.getDate (), 0);
			Assert::AreEqual (timeMacro.getMonth (), 0);
			Assert::AreEqual (timeMacro.getYear (), 0);
			Assert::AreEqual (timeMacro.getDay (), expectedDay);
		}

		//To test whether can update and get tomorrow's date correctly
		TEST_METHOD(testTomorrowDate)
		{
			Parser parser;
			TimeMacro timeMacro;
			string dayOfTheWeek = "Saturday";
			parser.getTomorrowDate (timeMacro);
			Assert::AreEqual (timeMacro.getDate(), 18);
			Assert::AreEqual (timeMacro.getMonth(), 4);
			Assert::AreEqual (timeMacro.getYear(), 2015);
			Assert::AreEqual (timeMacro.getDay(), dayOfTheWeek);
		}

		//To test whether can update and get this Monday's date correctly
		TEST_METHOD(testMonday)
		{
			Parser parser;
			TimeMacro timeMacro;
			parser.getMondayDate (timeMacro);
			Assert::AreEqual (timeMacro.getDate(), 13);
			Assert::AreEqual (timeMacro.getMonth(), 4);
			Assert::AreEqual (timeMacro.getYear(), 2015);
		}

		//To test whether can update and get this Sunday's date correctly
		TEST_METHOD(testSunday)
		{
			Parser parser;
			TimeMacro timeMacro;
			parser.getSundayDate (timeMacro);
			Assert::AreEqual (timeMacro.getDate(), 19);
			Assert::AreEqual (timeMacro.getMonth(), 4);
			Assert::AreEqual (timeMacro.getYear(), 2015);
		}

		//To test whether can update and get this month's date range correctly
		TEST_METHOD(testThisMonth)
		{
			Parser parser;
			TimeMacro timeMacroBeg;
			TimeMacro timeMacroEnd;
			parser.getThisMonth (timeMacroBeg, timeMacroEnd);
			Assert::AreEqual (timeMacroBeg.getDate(), 1);
			Assert::AreEqual (timeMacroBeg.getMonth(), 4);
			Assert::AreEqual (timeMacroBeg.getYear(), 2015);
			Assert::AreEqual (timeMacroEnd.getDate(), 30);
			Assert::AreEqual (timeMacroEnd.getMonth(), 4);
			Assert::AreEqual (timeMacroEnd.getYear(), 2015);
		}

		//To test whether can parse "show this month"
		TEST_METHOD(testParseShowThisMonth)
		{
			Parser parser;
			string userInput = "show this month";
			string commandWord = "show";
			parser.parseShow (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 1);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroEnd ()).getDate (), 30);
			Assert::AreEqual (((parser.getData ()).getTimeMacroEnd ()).getMonth (), 4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroEnd ()).getYear (), 2015);
		}

		//To test whether can parse "show this week"
		TEST_METHOD(testParseShowThisWeek)
		{
			Parser parser;
			string userInput = "show this week";
			string commandWord = "show";
			parser.parseShow (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 13);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroEnd ()).getDate (), 19);
			Assert::AreEqual (((parser.getData ()).getTimeMacroEnd ()).getMonth (), 4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroEnd ()).getYear (), 2015);
		}

		//To test whether can parse "show today"
		TEST_METHOD(testParseShowToday)
		{
			Parser parser;
			string userInput = "show today";
			string commandWord = "show";
			string expectedDay = "Friday";
			parser.parseShow (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 17);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
		}

		//To test whether can parse "show tomorrow"
		TEST_METHOD(testParseShowTomorrow)
		{
			Parser parser;
			string userInput = "show tomorrow";
			string commandWord = "show";
			string expectedDay = "Saturday";
			parser.parseShow (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 18);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (),4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
		}

		TEST_METHOD(testParseShowADay)
		{
			Parser parser;
			string userInput = "show 01/01/2000";
			string commandWord = "show";
			string expectedDay = "Saturday";
			parser.parseShow (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 1);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (),1);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2000);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
		}

		//To test whether can parse "show commands"
		TEST_METHOD(testParseShowCommands)
		{
			Parser parser;
			string userInput = "show commands";
			string commandWord = "show";
			parser.parseShow (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), userInput);
		}

		//To test whether can parse "clear"
		TEST_METHOD(testParseClear)
		{
			Parser parser;
			string userInput = "clear";
			string commandWord = "clear";
			parser.parseClear (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
		}

		//To test whether can parse "path"
		TEST_METHOD(testParsePath)
		{
			Parser parser;
			string userInput = "path c:/user/admin";
			string commandWord = "path";
			string path = "c:/user/admin";
			parser.parsePath (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getDirectory (), path);
		}

		//To test whether can parse "help"
		TEST_METHOD(testParseHelp)
		{
			Parser parser;
			string userInput = "help";
			string commandWord = "help";
			parser.parseHelp (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
		}

		//To test whether can parse a string to search for a single keyword
		TEST_METHOD(testParseSearchWord)
		{
			Parser parser;
			string userInput = "search breakfast";
			string commandWord = "search";
			string expectedDesc = "breakfast";
			parser.parseSearch (userInput, commandWord);
			
			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual ((parser.getData ()).getDesc (), expectedDesc);
		}

		//To test whether can parse a string to search for a string
		TEST_METHOD(testParseSearchPhrase)
		{
			Parser parser;
			string userInput = "search breakfast at UT";
			string commandWord = "search";
			string expectedDesc = "breakfast at UT";
			parser.parseSearch (userInput, commandWord);
			
			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual ((parser.getData ()).getDesc (), expectedDesc);
		}

		//To test whether can parse for "edit" feature
		//In this case, the task number has a single digit
		//and there is a starting time
		TEST_METHOD(testParseEdit)
		{
			Parser parser;
			string userInput = "edit 4 13/03/2015 09:00 breakfast";
			string commandWord = "edit";
			string expectedDay = "Friday";
			string expecedDesc = "breakfast";
			parser.parseEdit (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getTaskNo (), 4);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 13);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 3);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getHour (), 9);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getMin (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getHour (), -1);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getMin (), -1);
			Assert::AreEqual ((parser.getData ()).getDesc (), expecedDesc);
		}

		//To test whether can parse for "add" feature
		//In this case,there is a starting time
		TEST_METHOD(testParseAddStartingTime)
		{
			Parser parser;
			string userInput = "add 13/03/2015 19:00 dinner";
			string commandWord = "add";
			string expectedDay = "Friday";
			string expecedDesc = "dinner";
			parser.parseAdd (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 13);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 3);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getHour (), 19);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getMin (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getHour (), -1);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getMin (), -1);
			Assert::AreEqual ((parser.getData ()).getDesc (), expecedDesc);
		}


		//To test whether can parse for "add" feature
		//In this case,there is a time period
		TEST_METHOD(testParseAddPeriod)
		{
			Parser parser;
			string userInput = "add 13/03/2015 10:00-14:00 project work";
			string commandWord = "add";
			string expectedDay = "Friday";
			string expecedDesc = "project work";
			parser.parseAdd (userInput, commandWord);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 13);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 3);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getHour (), 10);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getMin (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getHour (), 14);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getMin (), 0);
			Assert::AreEqual ((parser.getData ()).getDesc (), expecedDesc);
		}

		//To test whether can parse for "add" feature
		TEST_METHOD(testParseInputAdd)
		{
			Parser parser;
			string userInput = "add 13/03/2015 10:00-14:00 project work";
			string expectedDay = "Friday";
			string expecedDesc = "project work";
			string commandWord = "add";
			parser.parseInput (userInput);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 13);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 3);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getHour (), 10);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getMin (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getHour (), 14);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getMin (), 0);
			Assert::AreEqual ((parser.getData ()).getDesc (), expecedDesc);
		}

		//To test whether can parse for "edit" feature
		TEST_METHOD(testParseInputEdit)
		{
			Parser parser;
			string userInput = "edit 9 13/03/2015 10:00 project work";
			string expectedDay = "Friday";
			string expecedDesc = "project work";
			string commandWord = "edit";
			parser.parseInput (userInput);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getTaskNo (), 9);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 13);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 3);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 2015);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getHour (), 10);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getMin (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getHour (), -1);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getMin (), -1);
			Assert::AreEqual ((parser.getData ()).getDesc (), expecedDesc);
		}

		//To test whether can parse for "delete" feature
		TEST_METHOD(testParseInputDelete)
		{
			Parser parser;
			string userInput = "delete 99";
			string expectedDay = "undefined";
			string expecedDesc = "";
			string commandWord = "delete";
			parser.parseInput (userInput);

			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getTaskNo (), 99);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDate (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getMonth (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getYear (), 0);
			Assert::AreEqual (((parser.getData ()).getTimeMacroBeg ()).getDay (), expectedDay);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getHour (), -1);
			Assert::AreEqual (((parser.getData ()).getTimeMicroBeg ()).getMin (), -1);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getHour (), -1);
			Assert::AreEqual (((parser.getData ()).getTimeMicroEnd ()).getMin (), -1);
			Assert::AreEqual ((parser.getData ()).getDesc (), expecedDesc);
		}

		//To test whether can parse for "mark it as done" feature
		//The boundary case is 1
		TEST_METHOD(testParseDone)
		{
			Parser parser;
			string input = "done 1";
			string commandWord = "done";
			parser.parseDone (input, commandWord);
			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getTaskNo (), 1);
			Assert::AreEqual ((parser.getData ()).getCompleteStatus (), true);
		}

		//To test whether error message is updated
		//if done is not followed by a task number.
		TEST_METHOD(testParseErrorDone)
		{
			Parser parser;
			string input = "done a";
			string errorMessage = "Please enter correct task number after command word";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage (), errorMessage);
		}

		//To test whether can parse for "mark it as undone" feature
		//The boundary case is 1
		TEST_METHOD(testParseUndone)
		{
			Parser parser;
			string input = "undone 1";
			string commandWord = "undone";
			parser.parseUndone (input, commandWord);
			Assert::AreEqual (parser.getCommand (), commandWord);
			Assert::AreEqual (parser.getTaskNo (), 1);
			Assert::AreEqual ((parser.getData ()).getCompleteStatus (), false);
		}

		//To test whether an error message is updated
		//when the date is invalid
		TEST_METHOD(testErrorDateAlphabet)
		{
			Parser parser;
			string input = "add 30 feb 2000 breakfast";
			string errorMessage = "Please enter the correct date";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage(), errorMessage);
		}

		//To test whether a string is a date
		//If it is an invalid date or month, an error message is updated.
		TEST_METHOD(testErrorDateNumber)
		{
			Parser parser;
			string input = "add 32/13/2015 breakfast";
			string errorMessage = "Please enter the correct date";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage(), errorMessage);
		}

		//To test whether an error message is updated
		//when the time is invalid
		TEST_METHOD(testErrorStartingTimeTwelve)
		{
			Parser parser;
			string input = "add 13.60am breakfast";
			string errorMessage = "Please enter the correct time";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage (), errorMessage);
		}

		//To test whether a string is a starting time
		//If it is an invalid time, an error message is updated
		TEST_METHOD(testErrorStartingTimeTwentyFour)
		{
			Parser parser;
			string input = "add 24:00 sleep";
			string errorMessage = "Please enter the correct time";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage(), errorMessage);
		}

		//To test whether an error message is updated
		//when the year is invalid
		TEST_METHOD(testErrorYearAlphabet)
		{
			Parser parser;
			string input = "add 8 apr 2101 breakfast";
			string errorMessage = "Please enter the correct year";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage(), errorMessage);
		}

		//To test whether an error message is updated
		//when the year is invalid
		TEST_METHOD(testErrorYearNumber)
		{
			Parser parser;
			string input = "add 12/12/2101 breakfast";
			string errorMessage = "Please enter the correct year";
			parser.parseInput (input);
			Assert::AreEqual (parser.getErrorMessage (), errorMessage);
		}

		//To test whether an error message is updated
		//when the word "clear" is followed by something else
		TEST_METHOD(testParseClearError)
		{
			Parser parser;
			string userInput = "clear 1";
			string commandWord = "clear";
			string errorMessage = "Please enter the correct command";
			parser.parseInput (userInput);
			Assert::AreEqual (parser.getErrorMessage (), errorMessage);
		}

		//To test whether an error message is updated
		//when the word "help" is followed by something else
		TEST_METHOD(testParseHelpError)
		{
			Parser parser;
			string userInput = "help a";
			string commandWord = "help";
			string errorMessage = "Please enter the correct command";
			parser.parseInput (userInput);
			Assert::AreEqual (parser.getErrorMessage (), errorMessage);
		}

	};
}
	// End of segment: C:\Users\Yang\Desktop\Projects\main\testParser\ParserUnitTest.cpp





	/**
	 * origin: C:\Users\Yang\Desktop\Projects\main\testParser\stdafx.h
	 */

#include "Parser.h"
// TODO: reference additional headers your program requires here

	// End of segment: C:\Users\Yang\Desktop\Projects\main\testParser\stdafx.h





